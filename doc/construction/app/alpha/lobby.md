# lobby 

사용자 인증과 방 생성과 진입을 처리하는 매우 단순한 프로토콜 구현을 통해 통신과 
분산 처리의 사용성을 완성하려고 합니다. 

pulse는 큰 도움이 되는 구조입니다. 하지만 더 많은 기능이 사전에 필요합니다. 
call() 처리가 필요한 서버간 세션을 알아야 하는 경우가 많습니다. 이를 관리하는 
구조가 필요합니다. 무엇일까요? 어디까지 추상화하여 갖고 있어야 할까요? 

약간 미묘한 면이 많습니다. 독립적으로 동작하는 객체들은 항상 소통이 필요합니다. 
소통은 매우 어려운 면이 있습니다. 미묘합니다. 하지만 모든 객체들은 변화하지만 
특정 면에서 고정되어 있습니다. 프로그램은 고정시킬 수 있습니다. 이 고정이 
프로토콜이 됩니다. 안정적인 프로토콜을 최대한 단순하게 (사용성을 만족하는 최소한)
구현합니다. 

## 서비스 알림과 찾기 

pulse 처럼 net 단에 두기는 어렵습니다. 애플리케이션에서 "사용"하여 구현할 수 있는 
구조가 더 적합해 보입니다. 아래에 있으면 맞출 수 없는 면이 있어 구조가 잘 안 나올 수 
있습니다. 

lobby_runner 서비스에서 필요한 것은 백엔드 서버의 세션입니다. pulse로 찾을 수도 
있지만 lobby_master는 연결을 받는 구조이기 때문에 같이 쓸 수 없습니다. 이를 위한 
단순한 프로토콜을 추가합니다. 

서비스 단에서 알 수 있는 정보를 추가합니다. service::syn_lobby_runner_up, 
service::syn_room_runner_up, service::syn_lobby_master_up, ... 많습니다. 
필요한 정보를 채울 수 있다는 면에서 좋습니다. 경험상 항상 필요하게 됩니다. 

늦게 실행된 서비스에서도 통지를 받도록 하려면 주기적인 배포가 필요합니다. 
클라로 실행되는 서비스에서 요청하고 응답을 받을 때까지 재시도 합니다. 

## back과 front의 처리 패턴 차이 

뒷단과 앞단은 프레임 처리 구조가 다릅니다. 앞단은 주로 플레이어나 방과 같은 
곳에서 세션 단위로 메세지를 받아서 처리합니다. 앞단에서 사용자 세션이 끊어지면 
그에 대한 처리를 하면 됩니다. 더 이상 해당 세션을 유지할 필요는 없고 
다른 연결로 갈아타도 해당 플레이어로 제한됩니다. 따라서, 단선이 영향을 미치는 
범위가 작습니다. 

뒷단과 연결을 사용하는 앞단의 서비스나 액터들은 해당 연결이 끊어지면 
관련된 에러 처리를 해야 합니다. 이를 일관되고 편하게 처리하기 위해 call() 기능을 
추가했습니다. call() 기능은 특정 세션 단위로만 동작합니다. 송수신 순서에 
의존하여 처리하기 때문에 세션이 섞이면 오동작할 가능성이 있습니다. 

뒷단과 단선시 해당 세션에 구독하고 있는 모든 pulse들은 새로운 세션으로 
새롭게 만들어야 합니다. 뒷단과 단선은 재앙(disaster)입니다. disaster recovery에 
해당하는 과정이므로 좀 무거워도 됩니다. 안정성이 가장 중요합니다. 

이와 같은 점들을 고려해야 하지만 pulse를 통해 사용 패턴을 제공하여 
효율적으로 쓸 수 있게 합니다. 내부 구현의 개선이 인터페이스 변경이 되지 않도록 
잘 살펴서 구현합니다. 

## auth_req_login_f2b의 처리 과정 

app_front를 만들고 pulse_back_을 추가하여 뒷단 연결을 맺습니다. 
start() 하기 전에 서비스들을 start() 하여 자체 pulse_back_을 준비합니다. 
established()에서 syn_lobby_runner_state를 전송합니다. 

뒷단에서 syn_lobby_runner_up에 대해 lobby_master에서 구독합니다. 
해당 메세지를 받으면 pulse를 하나 생성하여 lobby_runner와 통신할 수 있도록 합니다. 
여러 노드에서 이와 같은 메세지를 받으므로 관리 구조를 하나 둡니다. 
std::map<session_key, pulse*>와 같은 구조가 되겠습니다. 

room_runner와 room_master도 동일한 방식으로 동작 가능합니다. 
단선이 되고 새롭게 연결이 맺어지면 앞단 서버에서 초기화 과정을 동일하게 진행합니다. 
syn_lobby_master_up 프레임을 lobby_runner에서 구독하여 처리합니다. 

call()의 호출 오류도 처리할 수 있어야 합니다. 

## 









