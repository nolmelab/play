# alpha 

알파는 게임 기능 없이 인스턴스 내에서 채팅만 가능한 앱입니다. 

인증, 월드, 게임으로 이루어지는 플레이의 분산 처리 모델이 잘 동작하는지 검증하고 
가장 단순한 코드 기반으로 개별 게임에 맞는 기초(bare minimum)을 제공하기 위한 
프로젝트입니다. 

## 구조

앞단과 뒷단으로 나누어 서비스를 구성합니다. 사용자 인증과 방 처리로 
크게 나뉩니다. 

TODO: detail the structure and patterns

## 기능

- 인증
- 로비 진출입
- 방 진출입
- 방 채팅

db를 사용하지 않으면서 유용한 기능을 충분히 갖는 앱으로 적당합니다.

통신과 분산 처리 구조에 대한 사용성 검증을 충분히 하면서
ensure 봇들로 부하 테스트를 통해 성능과 안정성 검증도 할 수 있습니다.

## pulse와 분산 처리

분산 처리는 생각보다 어려운데 단선과 크래시가 구분되지 않는 문제가 그 시작입니다. 
요청을 보내고 해당 요청의 콜백에서 처리를 이어서 하게 되는데 (continutation) 
이 때 단선에 대해서도 동일한 처리를 에러 처리로 이어가야 합니다. 

이 처리를 매우 간단한 구조로 해결하려고 하는 아이디어가 pulse::call()입니다. 
rpc는 함수 형태로 IDL에서 생성한 호출로 동기 방식의 인터페이스를 사용하지만 
call()은 play 전체에 걸친 proactor 기반의 비동기 호출에 기초합니다. 

call() 호출 시 응답 토픽을 전달하고 call() 내부 구현에서 단선이나 전송 
실패가 발생하면 콜백을 통해 알려줍니다. 응답이 오면 관리 데이터를 제거합니다. 
토픽 아이디와 대기 응답 번호만 기억하므로 적은 데이터로 관리가 가능합니다. 

## 분산 처리의 패턴 

### 인증 

인증 관리 기능을 갖는 user_master와 사용자를 받아 방 진입까지 처리하는
lobby_runner의 두 단계 서비스로 분산된 구조입니다. 

lobby_runner에서 사용자의 인증 요청이 오면 pending 상태로 lobby_user_actor를 
만들어 시작하고 백엔드로 인증 요청을 전달합니다. lobby_user_actor에서 
단선과 추가 프레임에 대해 구독을 하여 처리합니다. 백엔드 인증이 완료되면 
이후에 구독을 하여 이전에 프레임 처리를 하지 않도록 할 수 있습니다. 

인증은 앞단과 뒷단의 두 단계로 구성되고 요청 => 요청 => 응답 => 응답의 
4 단계를 밟는 구조이고, 서비스와 사용자 액터의 2 층으로 구성되는 
분산 처리의 두 번째로 단순한 처리 구조입니다. 

가장 단순한 분산 처리는 사용자 요청을 대응하는 액터에서 받아 바로 
응답을 줄 수 있는 경우로 게임 플레이는 대부분 여기에 해당합니다. 

- 대응 구조 
  - lobby_runner <=> user_master 
  - lobby_user_actor <=> user_proxy 

- 프레임 흐름 
  - auth_req_login => auth_req_login_f2b => auth_syn_login_b2f => auth_res_login 

프로토콜의 규약을 실수를 적게 할 수 있도록 하고, 하나씩 찬찬히 구현하는 
수 밖에 없습니다. 현실에서도 서로 다른 개체 간의 위임은 그렇게 진행될 수 밖에 
없기 때문입니다. 

### 방 생성과 진출입 

방 생성과 진출입은 아마도 월드 서버를 만들면서 가장 복잡한 구조에 해당할 것입니다. 
실제 게임 구현은 다양한 옵션을 포함하게 되므로 더 많은 기능이 있겠지만 
알파에서는 가장 단순하게 분산 처리 구조를 드러내고 이를 깔끔하게 완성하는 것이 
목표이므로 방을 만들고 조회하고 진입하고 채팅하고 나가는 흐름만 구현합니다. 

방 생성 흐름은 다음과 같습니다. 

room_req_create => lobby_user_actor => room_req_create_f2b => room_master  
=> room_req_create_b2f => room_runner => room_res_create_f2b => room_master 
=> room_res_create_b2f => lobby_runner => room_res_create 

긴 흐름입니다. 또 뒷단에서 오는 프레임들의 처리는 세션으로 구분되지 않기에 
해당하는 액터에서 처리를 담지 못 하고 한번 더 액터를 찾아서 전달해야 합니다. 

토픽은 구분이 필수적이지만 실제 전달 내용을 담는 플랫버퍼 테이블은 공유할 수 
있습니다. 

방 생성과 방 진입 예약이 가장 깁니다. 이와 같은 경우 6 단계를 밟아야 합니다. 

여행사에 전화를 합니다. 일본 도쿄 근교의 호텔 예약을 신청합니다. 여행사 직원은 
예약이 가능한 호텔을 검색하거나 전화해서 알아봅니다. 호텔에 방을 정해서 예약합니다. 
방이 정해지면 사용자에게 알려줍니다. 

요청과 응답이 짝으로 이루어지고 연관된 개체가 3개이기에 6 단계의 토픽 처리가 
필요합니다. 필수적입니다. 

### 구현 진행 가이드

분산 처리는 이와 같이 여러 토픽을 여러 서비스와 액터에서 구독하고 구현하기 때문에 
귀찮게 느껴질 수 있습니다. 더 나은 방법을 계속 탐색해야 하지만 현실에서도 분산처리는 
요청과 응답, 뒷단의 다른 개체와 소통이 필요하기 때문에 여러 단계 처리는 
필수적이라고 봐야 합니다. 

- 반복되는 코드가 없도록 적절한 처리 위치를 찾고 함수로 만듭니다. 
- 액터에서 처리 가능한 경우는 액터에서 처리합니다. 
  - 앞단에서 세션을 사용하여 구독이 가능한 경우나 액터를 찾아서 전달 가능한 경우에 해당합니다. 
  - 구독 함수인 on_과 전달 함수인 do_로 표기하고 나눕니다. 
- 타이밍이나 에러 처리를 고려합니다. 

이런 귀찮을 수 있는 코드가 가치를 만들어 냅니다. 다른 측면에서 정성이라고 
생각해야 합니다. 더 많은 사용자를 수용하는 서비스를 가능하게 합니다. 

방이나 맵/필드/채널과 같이 중앙 관리가 필요하면서 분산된 개체에 대한 처리만 6단계의 
복잡한 구조가 필요하고 다른 기능은 요청 / 응답으로 대부분 가능합니다. 
친구나 길드와 같은 구조도 요청/응답을 두 번하는 4단계면 충분합니다 

